import re
import math
#execfile('parse.py')
#gretBoard.template-->dgsDigBoard.template
#gretCrystal.template-->dgsCrystal.template



def calcShift(mask):
	#find nonzero lsb
	mb=1
	shift=0;
	
	if (mask==0):
		return shift;
	
	while (mb&mask==0):
		mb=mb<<1
		shift=shift+1;
		
	return shift
	
def calcNBits(mask):
	#find nonzero lsb
	mb=1
	nbits=0;
	cnt=0
	
	
	for cnt in range(32):
		if (mb&mask!=0):
			nbits=nbits+1
		
		mb=mb<<1
			
		
	return nbits
	
#/home/oxygen26/TMADDEN/EPICS/DGS/gretTop/9-22/dgsDrivers/dgsDriverApp/Db


#go from raw mask to aaaa_nbits_shift- only works for longout rectuypes
def itransmask(filein, fileout,recspec):
	f = open(filein)
	f2=open(fileout,"w+")
	
	f3=open("asynlogfile.txt","w+")
	f2.write('\n#This file, %s, generated by parse.py from carlware template file %s\n\n' % (fileout, filein));
	f2.write("#format of asyn mask for longin/out is 0xaaaa_pp_qq, where pp is num of bits or NOBT, and qq is shift\n\n");
	f2.write("#format of asyn mask for other records is just a raw mask\n\n");
	try:
		nobt=-1;
		shft=-1;
		currentrec='';
		replacetype='asynUInt32Digital'
		
		for line in f:
			record=re.search('(?<=record).*',line)
			dtyp=re.search('(?<=field\(DTYP).*',line)
			out=re.search('(?<=field\(OUT).*',line)

			scan=re.search('(?<=field\(SCAN).*',line)
			inp=re.search('(?<=field\(INP).*',line)
			#field(SHFT, "
			shftx=re.search('(?<=field\(SHFT).*',line)
			endrec=re.search('}',line);
			nobtx=re.search('(?<=field\(NOBT).*',line)
			
			
			
			if endrec!=None:
				
				
				if recspec in rectype.group(0):
					if asyndigital == None:
						currentrec=currentrec+line;
						f2.write(currentrec);
						f3.write("long but not asyn\n");
					
					else:
						masks= re.split(',',outspec)[2];
						mask=int(masks,16);
						nbits =calcNBits(mask);
						shifts=calcShift(mask);
						cmask=int('0xaaaa0000',16) + (nbits<<8) + shifts
						outline2=outline.replace(masks,hex(cmask));
						currentrec=currentrec+outline2;
						currentrec=currentrec+line;
						f2.write(currentrec);
						f3.write("found mask %s, nbits=%d shifts=%d wrote %s\n"%(masks,nbits,shifts,hex(cmask)))
				else:
					if asyndigital == None:
						currentrec=currentrec+line;
						f2.write(currentrec);
					else:
						currentrec=currentrec+outline;
						currentrec=currentrec+line;
						f2.write(currentrec);
					
				
				

			
				
			elif record!=None:
				
				currentrec=line;
				nobt=-1;
				shft=-1;
				regname = '';
				bitnum=-1;
				is_out = -1;
				is_in=-1;
				asyndigital=None
				outline =""
				
				rectype=re.search('(?<=\()\w*',record.group(0))
				pvname=re.search('(?<=\")[$()\w]*',record.group(0))
				outspec='';
				scanspec = ''


				if pvname!= None and rectype!=None :
					f3.write( '\n\n**************************************\n')
					f3.write( 'PV= %s  Type= %s\n' % (pvname.group(0),rectype.group(0)))
				else:
					f3.write( '\n\n**************************************\n')
					f3.write( "NO PV or TYPE\n") 
			elif dtyp!=None :
				currentrec=currentrec+line;
				asyndigital=re.search(replacetype,dtyp.group(0));
				if asyndigital != None:
					
					f3.write( 'Found %s\n' % (replacetype))
					
			elif scan!=None :
				currentrec=currentrec+line;
				scanspec=re.search('(?<=")[$()\w /]*',line).group(0);
				f3.write('scanspec = %s\n' %(scanspec));
			
					
			elif out!=None :
			
				if asyndigital == None:
					currentrec=currentrec+line;
				else:
				
					outline = line;
					outspec=re.search('(?<=")[$\w@(), ]*',line).group(0);
					f3.write('Outspec = %s\n' %(outspec));
					
					
			elif inp!=None:
				if asyndigital == None:
					currentrec=currentrec+line;
				else:
				
					outline = line;
					outspec=re.search('(?<=")[$\w@(), ]*',line).group(0);
					f3.write('Outspec = %s\n' %(outspec));
					
			
			
			else:
				currentrec=currentrec+line;
			

	finally:
		f3.write("\n\n-------------END PARSE---------------\n")
		f.close()
		f2.close()
    












#/home/oxygen26/TMADDEN/EPICS/DGS/gretTop/9-22/dgsDrivers/dgsDriverApp/Db
#go from mask aabb to -xffffff type mask- bits_shift to raw mask
def transmask(filein, fileout,recspec):
	f = open(filein)
	f2=open(fileout,"w+")
	
	f3=open("asynlogfile.txt","w+")
	f2.write('\n#This file, %s, generated by parse.py from carlware template file %s\n\n' % (fileout, filein));
	f2.write("#format of asyn mask is 0x0000_pp_qq, where pp is num of bits or NOBT, and qq is shift\n\n");
	try:
		nobt=-1;
		shft=-1;
		currentrec='';
		replacetype='asynUInt32Digital'
		
		for line in f:
			record=re.search('(?<=record).*',line)
			dtyp=re.search('(?<=field\(DTYP).*',line)
			out=re.search('(?<=field\(OUT).*',line)

			scan=re.search('(?<=field\(SCAN).*',line)
			inp=re.search('(?<=field\(INP).*',line)
			#field(SHFT, "
			shftx=re.search('(?<=field\(SHFT).*',line)
			endrec=re.search('}',line);
			nobtx=re.search('(?<=field\(NOBT).*',line)
			
			
			
			if endrec!=None:
				
				
				if recspec in rectype.group(0):
	
					if asyndigital == None:
						currentrec=currentrec+line;
						f2.write(currentrec);
					
					else:
						masks= re.split(',',outspec)[2];
						mask=int(masks,16);
						mask=mask&0xffff;
						nbits = mask>>8;
						shifts=mask&0xff;
						cmask=((1<<nbits)-1) <<shifts;
						outline2=outline.replace(masks,hex(int(cmask)));
						currentrec=currentrec+outline2;
						currentrec=currentrec+line;
						f2.write(currentrec);
				else:
					if asyndigital == None:
						currentrec=currentrec+line;
						f2.write(currentrec);
					else:
						currentrec=currentrec+outline;
						currentrec=currentrec+line;
						f2.write(currentrec);
					
								

			
				
			elif record!=None:
				
				currentrec=line;
				nobt=-1;
				shft=-1;
				regname = '';
				bitnum=-1;
				is_out = -1;
				is_in=-1;
				asyndigital=None
				outline =""
				
				rectype=re.search('(?<=\()\w*',record.group(0))
				pvname=re.search('(?<=\")[$()\w]*',record.group(0))
				outspec='';
				scanspec = ''


				if pvname!= None and rectype!=None :
					f3.write( '\n\n**************************************\n')
					f3.write( 'PV= %s  Type= %s\n' % (pvname.group(0),rectype.group(0)))
				else:
					f3.write( '\n\n**************************************\n')
					f3.write( "NO PV or TYPE\n") 
			elif dtyp!=None :
				currentrec=currentrec+line;
				asyndigital=re.search(replacetype,dtyp.group(0));
				if asyndigital != None:
					
					f3.write( 'Found %s\n' % (replacetype))
					
			elif scan!=None :
				currentrec=currentrec+line;
				scanspec=re.search('(?<=")[$()\w /]*',line).group(0);
				f3.write('scanspec = %s\n' %(scanspec));
			
					
			elif out!=None :
			
				if asyndigital == None:
					currentrec=currentrec+line;
				else:
				
					outline = line;
					outspec=re.search('(?<=")[$\w@(), ]*',line).group(0);
					f3.write('Outspec = %s\n' %(outspec));
					
					
			elif inp!=None:
				if asyndigital == None:
					currentrec=currentrec+line;
				else:
				
					outline = line;
					outspec=re.search('(?<=")[$\w@(), ]*',line).group(0);
					f3.write('Outspec = %s\n' %(outspec));
					
			
			
			else:
				currentrec=currentrec+line;
			

	finally:
		f3.write("\n\n-------------END PARSE---------------\n")
		f.close()
		f2.close()
    







longoutrec="""

record(longout, "_PVNAME_") {
  field(DTYP, "asynUInt32Digital")
  field(OUT,  "_OUTSPEC_")
}


"""

longinrec="""


record(longin, "_PVNAME_") {
  field(PINI, "1")
  field(DTYP, "asynUInt32Digital")
  field(INP,  "_INSPEC_")
  field(SCAN, "_SCANSPEC_")
}

"""


# convert ao recs from asyn to softsupport and output to longout. longout will be asyndigitial
def ff3(filein, fileout) :
	f = open(filein)
	f2=open(fileout,"w+")
	
	f3=open("asynlogfile.txt","w+")
	f2.write('\n#This file, %s, generated by parse.py from carlware template file %s\n\n' % (fileout, filein));
	f2.write("#format of asyn mask is 0x0000_pp_qq, where pp is num of bits or NOBT, and qq is shift\n\n");
	try:
		nobt=-1;
		shft=-1;
		currentrec='';
		replacetype='Gretina Trigger'
		
		for line in f:
			record=re.search('(?<=record).*',line)
			dtyp=re.search('(?<=field\(DTYP).*',line)
			out=re.search('(?<=field\(OUT).*',line)

			scan=re.search('(?<=field\(SCAN).*',line)
			inp=re.search('(?<=field\(INP).*',line)
			#field(SHFT, "
			shftx=re.search('(?<=field\(SHFT).*',line)
			endrec=re.search('}',line);
			nobtx=re.search('(?<=field\(NOBT).*',line)
			
			currentrec=currentrec+line;
			
			if endrec!=None:
				#format is 0000 nobt_shift  where we have 8bits for num of bits, 0-32, and 8 bits for shift, 0 to 32.
				if 'ao'in rectype.group(0):
					if asyndigital!=None:

						pvnamelong=pvname.group(0)+'LONGOUT';
						lrec=longoutrec;
						lrec=lrec.replace('_PVNAME_',pvnamelong)
						lrec=lrec.replace('_OUTSPEC_',outspec);

						f2.write(lrec);
						f3.write(" Write long out: %s %s\n" % (pvnamelong, outspec))
						
						currentrecb=currentrec.replace(replacetype,'Soft Support')
						currentrecb=currentrecb.replace(outspec, '%s PP NMS' %(pvnamelong));
						f2.write(currentrecb);
						f3.write('write soft support ao\n');
					else:
						f2.write(currentrec);

				elif 'ai'in rectype.group(0):
					if asyndigital!=None:

						pvnamelong=pvname.group(0)+'LONGIN';
						lrec=longinrec;
						lrec=lrec.replace('_PVNAME_',pvnamelong)
						lrec=lrec.replace('_INSPEC_',outspec);
						if len(scanspec)>0:	
							lrec=lrec.replace('_SCANSPEC_',scanspec);
						else:
							lrec=lrec.replace('_SCANSPEC_','I/O Intr');


						f2.write(lrec);
						f3.write(" Write long in: %s %s\n" % (pvnamelong, outspec))
						
						currentrecb=currentrec.replace(replacetype,'Soft Support')
						currentrecb=currentrecb.replace(outspec, '%s PP NMS' %(pvnamelong));
						f2.write(currentrecb);
						f3.write('write soft support ai\n');
					else:
						f2.write(currentrec);
					
				else:
					f2.write(currentrec);

			
				
			elif record!=None:
				
				currentrec=line;
				nobt=-1;
				shft=-1;
				regname = '';
				bitnum=-1;
				is_out = -1;
				is_in=-1;
				asyndigital=None
				
				rectype=re.search('(?<=\()\w*',record.group(0))
				pvname=re.search('(?<=\")[$()\w]*',record.group(0))
				outspec='';
				scanspec = ''


				if pvname!= None and rectype!=None :
					f3.write( '\n\n**************************************\n')
					f3.write( 'PV= %s  Type= %s\n' % (pvname.group(0),rectype.group(0)))
				else:
					f3.write( '\n\n**************************************\n')
					f3.write( "NO PV or TYPE\n") 
			elif dtyp!=None :
				f3.write( 'DTYP %s\n' % (dtyp.group(0)))
			
				asyndigital=re.search(replacetype,dtyp.group(0));
				if asyndigital != None:
					
					f3.write( 'Found %s\n' % (replacetype))
					
			elif scan!=None :
				
				scanspec=re.search('(?<=")[$()\w /]*',line).group(0);
				f3.write('scanspec = %s\n' %(scanspec));
			
					
			elif out!=None :
				
				outspec=re.search('(?<=")[$\w@(), ]*',line).group(0);
				f3.write('Outspec = %s\n' %(outspec));
			elif inp!=None:

		
				outspec=re.search('(?<=")[$\w@(), ]*',line).group(0);
				f3.write('Inspec = %s\n' %(outspec));
			

	finally:
		f3.write("\n\n-------------END PARSE---------------\n")
		f.close()
		f2.close()
    








def ff1(filein, fileout) :
	f = open(filein)
	f2=open(fileout,"w+")
	f3=open("asynlogfile.txt","w+")
	f2.write('\n#This file, %s, generated by parse.py from carlware template file %s\n\n' % (fileout, filein));
	f2.write("#format of asyn mask is 0x0000_pp_qq, where pp is num of bits or NOBT, and qq is shift\n\n");
	try:
		nobt=-1;
		shft=-1;
		
		
		for line in f:
			record=re.search('(?<=record).*',line)
			dtyp=re.search('(?<=field\(DTYP).*',line)
			out=re.search('(?<=field\(OUT).*',line)
			inp=re.search('(?<=field\(INP).*',line)
			#field(SHFT, "
			shftx=re.search('(?<=field\(SHFT).*',line)
			endrec=re.search('}',line);
			nobtx=re.search('(?<=field\(NOBT).*',line)
			
			
			
			if endrec!=None:
				#format is aaaa_nobt_shift  where we have 8bits for num of bits, 0-32, and 8 bits for shift, 0 to 32.
				mask=32*256;
				if bitnum>-1:
					#b0 is 1 bit, bit number is the shift
					mask=1*256 + bitnum;
				elif shft>-1:
					mask= nobt*256 + shft
				elif nobt>-1:
					mask= nobt*256;
					#print mask
					
					
				mask=mask + 0xaaaa0000
				masks=hex(mask);
				#remove L from mask
				is_l = re.search('L',masks);
				if is_l!=None:
					masks=masks[0:len(masks)-1]
				
				if is_in==1:
				
				
					newline = '  field(INP,  \"@asynMask($(PORT),$(ADDR),%s, $(TIMEOUT))%s \")\n' % (masks, regname)
					
				elif is_out==1:
					newline = '  field(OUT,  \"@asynMask($(PORT),$(ADDR),%s, $(TIMEOUT))%s \")\n' % (masks, regname)
				else:
					newline="";
					f3.write('No Output field\n');

				f2.write(newline);
				f2.write(line);
				f3.write(newline);
				
			
			elif nobtx!=None:
				nobt=int(re.search('(?<=\")\w*',nobtx.group(0)).group(0))
				f3.write("NOBT  = %d\n" %(nobt))
				f2.write(line);
					
			elif shftx!=None:
				shft=int(re.search('(?<=\")\w*',shftx.group(0)).group(0))
				f3.write("SHFT  = %d\n" %(shft))
				f2.write(line);
				
			elif record!=None:
				
				nobt=-1;
				shft=-1;
				regname = '';
				bitnum=-1;
				is_out = -1;
				is_in=-1;
				
				f2.write(line);
				rectype=re.search('(?<=\()\w*',record.group(0))
				pvname=re.search('(?<=\")[$()\w]*',record.group(0))
				if pvname!= None and rectype!=None :
					f3.write( '\n\n**************************************\n')
					f3.write( 'PV= %s  Type= %s\n' % (pvname.group(0),rectype.group(0)))
				else:
					f3.write( '\n\n**************************************\n')
					f3.write( "NO PV or TYPE\n") 
			elif dtyp!=None :
			
				gretdig=re.search('Gretina Digitizer',dtyp.group(0));
				if gretdig != None:
					newline='  field(DTYP,\"asynUInt32Digital\")\n'
					f3.write( 'Gretina Digitizer-->asynUInt32Digital\n')
					f2.write(newline)
				else :
					f3.write( 'DTYP =  %s\n' % dtyp.group(0))
					newline = line
					f2.write(newline);
					
			elif out!=None :
				addr=re.search('(?<=S0x)\w*',out.group(0))
				
				bit=re.search('(?<=@)\w*',out.group(0))
				f3.write( "Out= " + out.group(0)+"\n")
				if addr!=None:
					is_out = 1;
					newline='';
					f3.write( 'Addr= %d\n' % int(addr.group(0),16))
					regname=addr_list.get(int(addr.group(0),16))
					if regname==None:
						regname=addr.group(0)
						f3.write("##CANNOT MAP REGISTER##\n")
					f3.write( 'regname = %s\n' % regname)
					if bit!= None :
						if len(bit.group(0)) > 0 :
							bitnum=int(bit.group(0))
				
						
					
				else:
					f3.write( "No Address\n")
					newline=line
					

				f2.write(newline)
			elif inp!=None:
				
				addr=re.search('(?<=S0x)\w*',inp.group(0))
				
				bit=re.search('(?<=@)\w*',inp.group(0))
				f3.write( "INP= " + inp.group(0)+"\n")
				if addr!=None:
					is_in = 1;
					newline='';
					f3.write( 'Addr= %d\n' % int(addr.group(0),16))
					regname=addr_list.get(int(addr.group(0),16))
					if regname==None:
						regname=addr.group(0)
					f3.write( 'regname = %s\n' % regname)
					if bit!= None :
						if len(bit.group(0)) > 0 :
							bitnum=int(bit.group(0))
							
						
						
					
				else:
					f3.write( "No Address\n")
					newline=line
					

				f2.write(newline)
			
			else :
				f2.write(line);

	finally:
		f3.write("\n\n-------------END PARSE---------------\n")
		f.close()
		f2.close()
    





#record(longout, "$(P)$(R)reg_board_id") {
#  field(DTYP, "asynUInt32Digital")
#  field(OUT,  "@asynMask($(PORT),$(ADDR),0xaaaa2000,$(TIMEOUT))reg_board_id")
#}

def asynLongOut(filename) :
	tfile = open(filename,'w+');
	tfile.write("# This is pyuthon gen file for asyn");
	pvfile = open('pv_out.txt','w+');
	
	indices = range(0,len(addr_list)-1);
	
	pvnamelist = addr_list.values();
	addresses = addr_list.keys();

	for ii in indices :
		param=pvnamelist[ii];
		adr = addresses[ii];
		
		tfile.write(" ");
		tfile.write("\n");  
		tfile.write(" ");  
		tfile.write("\n");  
		pvname="$(P)$(R)%s" % (param)
		pvfile.write(pvname+"\n");
		print "Making " + pvname
		strx = "record(longout, \"%s\") {" % (pvname)
		tfile.write(strx);  
		tfile.write("\n");  
		strx = "  field(DTYP, \"asynUInt32Digital\")"
		tfile.write(strx);  
		tfile.write("\n");  

		strx = "  field(DESC, \"Address 0x%x\")" % (adr)
		tfile.write(strx);  
		tfile.write("\n");  



		strx = "  field(OUT,  \"@asyn($(PORT),0,0xaaaa2000,1)%s\")" % (param)
		tfile.write(strx);  
		tfile.write("\n");  
		
		tfile.write("}\n\n");
	
	tfile.close();
	pvfile.close();






#record(longout, "$(P)$(R)reg_board_id") {
#  field(DTYP, "asynUInt32Digital")
#  field(OUT,  "@asynMask($(PORT),$(ADDR),0xaaaa2000,$(TIMEOUT))reg_board_id")
#}

def asynLongIn(filename) :
	tfile = open(filename,'w+');
	tfile.write("# This is pyuthon gen file for asyn");
	pvfile = open('pv_out.txt','w+');
	
	indices = range(0,len(addr_list)-1);
	
	pvnamelist = addr_list.values();
	addresses = addr_list.keys();

	for ii in indices :
		param=pvnamelist[ii];
		adr = addresses[ii];
		
		tfile.write(" ");
		tfile.write("\n");  
		tfile.write(" ");  
		tfile.write("\n");  
		pvname="$(P)$(R)%s_RBV" % (param)
		pvfile.write(pvname+"\n");
		print "Making " + pvname
		strx = "record(longin, \"%s\") {" % (pvname)
		tfile.write(strx);  
		tfile.write("\n");  

		tfile.write("  field(PINI, \"1\")\n");  

		
		strx = "  field(DTYP, \"asynUInt32Digital\")"
		tfile.write(strx);  
		tfile.write("\n");  

		strx = "  field(DESC, \"Address 0x%x\")" % (adr)
		tfile.write(strx);  
		tfile.write("\n");  

		tfile.write("  field(SCAN, \"I/O Intr\")\n");


		strx = "  field(INP,  \"@asyn($(PORT),0,0xaaaa2000,1)%s\")" % (param)
		tfile.write(strx);  
		tfile.write("\n");  
		
		tfile.write("}\n\n");
	
	tfile.close();
	pvfile.close();








addr_list=dict()

def setAddress(regname,regaddr) :
	addr_list[regaddr]=regname
	


def makeAddrListDig() :


	setAddress('reg_jta_diag1',0x17c);
	setAddress('reg_bgo_d_window',0x180);
	setAddress('reg_bgo_k_window ',0x184);
	setAddress('reg_bgo_m_window ',0x188);
	setAddress('reg_channel_pulsed_control',0x190);
	setAddress('REG_0194',0x194);
	setAddress('REG_0198',0x198);
	setAddress('REG_019C',0x19C);
	setAddress('REG_01A0',0x1A0);
	setAddress('REG_01A4',0x1A4);
	setAddress('REG_01A8',0x1A8);
	setAddress('REG_01AC',0x1AC);
	setAddress('REG_01B0',0x1B0);
	setAddress('REG_01B4',0x1B4);
	setAddress('REG_01B8',0x1B8);
	setAddress('REG_01BC',0x01BC);
	setAddress('REG_01C0',0x01C0);
	setAddress('REG_01C4',0x01C4);
	setAddress('REG_01C8',0x01C8);
	setAddress('REG_01CC',0x01CC);
	setAddress('REG_01D0',0x01D0);
	setAddress('REG_01D4',0x01D4);
	setAddress('REG_01D8',0x01D8);
	setAddress('REG_01DC',0x01DC);
	setAddress('REG_01E0',0x01E0);
	setAddress('REG_01E4',0x01E4);
	setAddress('REG_01E8',0x01E8);
	setAddress('REG_01EC',0x01EC);
	setAddress('REG_01F0',0x01F0);
	setAddress('REG_01F4',0x01F4);
	setAddress('REG_01F8',0x01F8);
	setAddress('reg_diag_channel_input',0x1FC);
	
	setAddress('regin_fbus_status',0x480);
	setAddress('regin_latched_timestamp_lsb',0x484);
	setAddress('regin_latched_timestamp_msb',0x488);
	setAddress('regin_live_timestamp_lsb',0x48C);
	setAddress('regin_live_timestamp_msb',0x490);

	
	setAddress('regin_master_logic_status',0x500);

	
	setAddress('reg_fbus_mdata_receive_0',0x554);
	setAddress('reg_fbus_mdata_receive_1',0x558);
	setAddress('reg_fbus_mdata_receive_2',0x55C);
	setAddress('reg_fbus_mdata_receive_3',0x560);
	setAddress('reg_fbus_mdata_receive_4',0x564);
	setAddress('reg_fbus_mdata_receive_5',0x568);
	setAddress('reg_fbus_mdata_receive_6',0x56C);
	setAddress('reg_fbus_mdata_receive_7',0x570);
	setAddress('reg_fbus_mdata_receive_8',0x574);
	setAddress('reg_fbus_mdata_receive_9',0x578);
	setAddress('reg_fbus_mdata_receive_10',0x57C);
	
	setAddress('regin_sd_read',0x840);
	setAddress('reg_board_id',0x000);
	setAddress('reg_programming_done',0x004);
	setAddress('reg_external_window',0x008);
	setAddress('reg_pileup_window',0x00C);
	setAddress('reg_noise_window',0x010);
	setAddress('reg_ext_trig_length',0x014);
	setAddress('reg_collection_time',0x018);
	setAddress('reg_integration_time',0x01C);
	setAddress('reg_hardware_status',0x020);
	setAddress('reg_user_package_data',0x024);

	setAddress('reg_control_status_0',0x040);
	setAddress('reg_control_status_1',0x044);
	setAddress('reg_control_status_2',0x048);
	setAddress('reg_control_status_3',0x04C);
	setAddress('reg_control_status_4',0x050);
	setAddress('reg_control_status_5',0x054);
	setAddress('reg_control_status_6',0x058);
	setAddress('reg_control_status_7',0x05C);
	setAddress('reg_control_status_8',0x060);
	setAddress('reg_control_status_9',0x064);

	setAddress('reg_led_threshold_0',0x080);
	setAddress('reg_led_threshold_1',0x084);
	setAddress('reg_led_threshold_2',0x088);
	setAddress('reg_led_threshold_3',0x08C);
	setAddress('reg_led_threshold_4',0x090);
	setAddress('reg_led_threshold_5',0x094);
	setAddress('reg_led_threshold_6',0x098);
	setAddress('reg_led_threshold_7',0x09C);
	setAddress('reg_led_threshold_8',0x0A0);
	setAddress('reg_led_threshold_9',0x0A4);


	setAddress('reg_cfd_parameters_0',0x0C0);
	setAddress('reg_cfd_parameters_1',0x0C4);
	setAddress('reg_cfd_parameters_2',0x0C8);
	setAddress('reg_cfd_parameters_3',0x0CC);
	setAddress('reg_cfd_parameters_4',0x0D0);
	setAddress('reg_cfd_parameters_5',0x0D4);
	setAddress('reg_cfd_parameters_6',0x0D8);
	setAddress('reg_cfd_parameters_7',0x0DC);
	setAddress('reg_cfd_parameters_8',0x0E0);
	setAddress('reg_cfd_parameters_9',0x0E4);

	setAddress('reg_raw_data_length_0',0x100);
	setAddress('reg_raw_data_length_1',0x104);
	setAddress('reg_raw_data_length_2',0x108);
	setAddress('reg_raw_data_length_3',0x10C);
	setAddress('reg_raw_data_length_4',0x110);
	setAddress('reg_raw_data_length_5',0x114);
	setAddress('reg_raw_data_length_6',0x118);
	setAddress('reg_raw_data_length_7',0x11C);
	setAddress('reg_raw_data_length_8',0x120);
	setAddress('reg_raw_data_length_9',0x124);

	
	setAddress('reg_raw_data_window_0',0x140);
	setAddress('reg_raw_data_window_1',0x144);
	setAddress('reg_raw_data_window_2',0x148);
	setAddress('reg_raw_data_window_3',0x14C);
	setAddress('reg_raw_data_window_4',0x150);
	setAddress('reg_raw_data_window_5',0x154);
	setAddress('reg_raw_data_window_6',0x158);
	setAddress('reg_raw_data_window_7',0x15C);
	setAddress('reg_raw_data_window_8',0x160);
	setAddress('reg_raw_data_window_9',0x164);


	
	setAddress('reg_ge_d_window',0x170);
	setAddress('reg_ge_k_window',0x174);
	setAddress('reg_ge_m_window',0x178);


	setAddress('reg_dac',0x400	);
	setAddress('reg_fbus_status',0x480);

	setAddress('reg_fbus_sdata_send_0',0x494);
	setAddress('reg_fbus_sdata_send_1',0x498);
	setAddress('reg_fbus_sdata_send_2',0x49C);
	setAddress('reg_fbus_sdata_send_3',0x4A0);
	setAddress('reg_fbus_sdata_send_4',0x4A4);
	setAddress('reg_fbus_sdata_send_5',0x4A8);
	setAddress('reg_fbus_sdata_send_6',0x4AC);
	setAddress('reg_fbus_sdata_send_7',0x4B0);
	setAddress('reg_fbus_sdata_send_8',0x4B4);

	setAddress('reg_fbus_unused',0x4B8);

	
	setAddress('reg_fbus_sdata_receive_0',0x4D4);
	setAddress('reg_fbus_sdata_receive_1',0x4D8);
	setAddress('reg_fbus_sdata_receive_2',0x4DC);
	setAddress('reg_fbus_sdata_receive_3',0x4E0);
	setAddress('reg_fbus_sdata_receive_4',0x4E4);
	setAddress('reg_fbus_sdata_receive_5',0x4E8);
	setAddress('reg_fbus_sdata_receive_6',0x4EC);
	setAddress('reg_fbus_sdata_receive_7',0x4F0);
	setAddress('reg_fbus_sdata_receive_8',0x4F4);
	setAddress('reg_fbus_sdata_receive_9',0x4F8);
	setAddress('reg_fbus_sdata_receive_10',0x4FC);
	


	setAddress('reg_master_logic_status',0x500);
	setAddress('reg_ccled_timer',0x504);
	setAddress('reg_deltat_X55',0x508);
	setAddress('reg_deltat_X5A',0x50C);
	setAddress('reg_deltat_XA5',0x510);
			
	setAddress('reg_snapshot',0x514	);
	setAddress('reg_xtal_id',0x518);
	setAddress('reg_get_hit_pattern_time',0x51C);
	setAddress('reg_fbus_command',0x520);
	setAddress('reg_test_dig_rx_ttcl',0x524);

	
	setAddress('reg_fbus_mdata_send_0',0x528);
	setAddress('reg_fbus_mdaasynTrigRouterInOut.templateta_send_1',0x52C);
	setAddress('reg_fbus_mdata_send_2',0x530);
	setAddress('reg_fbus_mdata_send_3',0x534);
	setAddress('reg_fbus_mdata_send_4',0x538);
	setAddress('reg_fbus_mdata_send_5',0x53C);
	setAddress('reg_fbus_mdata_send_6',0x540);
	setAddress('reg_fbus_mdata_send_7',0x544);
	setAddress('reg_fbus_mdata_send_8',0x548);
	setAddress('reg_fbus_mdata_send_9',0x54C);
	setAddress('reg_fbus_mdata_send_10',0x550);
	
	
	setAddress('reg_fbus_mdata_receive_0',0x554);
	setAddress('reg_fbus_mdata_receive_1',0x558);
	setAddress('reg_fbus_mdata_receive_2',0x55C);
	setAddress('reg_fbus_mdata_receive_3',0x560);
	setAddress('reg_fbus_mdata_receive_4',0x564);
	setAddress('reg_fbus_mdata_receive_5',0x568);
	setAddress('reg_fbus_mdata_receive_6',0x56C);
	setAddress('reg_fbus_mdata_receive_7',0x570);
	setAddress('reg_fbus_mdata_receive_8',0x574);
	setAddress('reg_fbus_mdata_receive_9',0x578);
	setAddress('reg_fbus_mdata_receive_10',0x57C);
	
	
	
	setAddress('reg_debug_data_buffer_addr',0x780);
	setAddress('reg_debug_data_buffer_data',0x784);
	setAddress('reg_led_flag_window',0x788);
			
	setAddress('reg_ADC_clock_control',0x78C);
	setAddress('reg_aux_io_read',0x800);
	setAddress('reg_aux_io_write',0x804);
	setAddress('reg_aux_io_config',0x808);
	setAddress('reg_fb_read',0x820);
	setAddress('reg_fb_write',0x824);
	setAddress('reg_fb_config',0x828);
	setAddress('reg_sd_read',0x840);
	setAddress('reg_sd_write',0x844);
	setAddress('reg_sd_config',0x848);
			
	setAddress('reg_adc_config',0x84C);
	setAddress('reg_self_trigger_enable',0x860);
	setAddress('reg_self_trigger_period',0x864);
	setAddress('reg_self_trigger_count',0x868);




def makeAddrListTrigRouter() :


	setAddress('RC_STATE',0x0124);





def makeAddrListTrigMaster() :


	setAddress('GITMO_LOCK_COUNT',0x0110);
	setAddress('MSM_STATE',0x0120);
	setAddress('RC_STATE',0x0124);
	setAddress('GITMO_STAT1',0x01D4);
	setAddress('GITMO_STAT2',0x01D8);
	setAddress('GITMO_ERROR_COUNT',0x01DC);
	setAddress('AUX_TRIGGER_WIDTH',0x0824);
	setAddress('TRIG_MASK',0x0850);
	setAddress('TRIG_DEST_MASK',0x0854);
	setAddress('SYNC_RST_RT_FIFO_MASK',0x0858);
	setAddress('SYNC_RST_RT_DIAG_MASK',0x085C);
	setAddress('SERDES_MULT_THRESH',0x0860);
	setAddress('TW_ETHRESH_CTL',0x0864);
	setAddress('TW_ETHRESH_LOW',0x0868);
	setAddress('TW_ETHRESH_HIGH',0x086C);
	setAddress('RAW_ETHRESH_LOW',0x0870);
	setAddress('RAW_ETHRESH_HIGH',0x0874);
	setAddress('ISOMER_THRESH1',0x0878);
	setAddress('ISOMER_THRESH2',0x087C);
	setAddress('ISOMER_TIME_WIN',0x0880);
	setAddress('CHAN_FIFO_THRESH_B',0x0884);
	setAddress('CHAN_FIFO_THRESH_C',0x0888);
	setAddress('SYNC_RST_MT_FIFO_MASK',0x088C);
	setAddress('SYNC_RST_MT_DIAG_MASK',0x0890);
	setAddress('ISOMER_THRESH3',0x0894);
	setAddress('DATA_GENERATOR_RESETS_REG',0x0898);
	setAddress('ISOMER_THRESH4',0x089C);
	setAddress('DELAYED_FS_DELAY_REG',0x08C4);
	setAddress('GITMO_PATTERN_TRIGGER',0x08C8);
	setAddress('SYNC_RST_TIMESTAMP',0x08DC);
	setAddress('ASYNC_CMD_FIFO',0x08F4);
	setAddress('AUX_CMD_FIFO',0x08F8);
	setAddress('FS_PARTIAL_A',0xA010);
	setAddress('FS_PARTIAL_B',0xA014);
	setAddress('FS_PARTIAL_C',0xA018);
	setAddress('FS_PARTIAL_D',0xA01C);
	setAddress('FS_TOTAL_MULTIPLICITY',0xA004);
	











def makeAddrListTrigCommon() :


	setAddress('LINK_LOCKED',0x0100);
	setAddress('LINK_DEN',0x0104);
	setAddress('LINK_REN',0x0108);
	setAddress('LINK_SYNC',0x010C);
	setAddress('TIMESTAMP_A',0x0114);
	setAddress('TIMESTAMP_B',0x0118);
	setAddress('TIMESTAMP_C',0x011C);
	setAddress('MISC_STAT',0x0128);
	setAddress('Diagnostic_A',0x012C);
	setAddress('Diagnostic_B',0x0130);
	setAddress('Diagnostic_C',0x0134);
	setAddress('Diagnostic_D',0x0138);
	setAddress('Diagnostic_E',0x013C);
	setAddress('Diagnostic_F',0x0140);
	setAddress('Diagnostic_G',0x0144);
	setAddress('Diagnostic_H',0x0148);
	setAddress('DIAG_STAT',0x014C);
	setAddress('CODE_DATE',0x0158);
	setAddress('CODE_REVISION',0x015C);
	setAddress('MON1_FIFO',0x0160);
	setAddress('MON2_FIFO',0x0164);
	setAddress('MON3_FIFO',0x0168);
	setAddress('MON4_FIFO',0x016C);
	setAddress('MON5_FIFO',0x0170);
	setAddress('MON6_FIFO',0x0174);
	setAddress('MON7_FIFO',0x0178);
	setAddress('MON8_FIFO',0x017C);
	setAddress('CHAN1_FIFO',0x0180);
	setAddress('CHAN2_FIFO',0x0184);
	setAddress('CHAN3_FIFO',0x0188);
	setAddress('CHAN4_FIFO',0x018C);
	setAddress('CHAN5_FIFO',0x0190);
	setAddress('CHAN6_FIFO',0x0194);
	setAddress('CHAN7_FIFO',0x0198);
	setAddress('CHAN8_FIFO',0x019C);
	setAddress('MON_FIFO_STAT',0x01A0);
	setAddress('CHAN_FIFO_STAT',0x01A4);
	setAddress('INPUT_LINK_MASK',0x0800);
	setAddress('LED_REGISTER',0x0804);
	setAddress('SKEW_CTL_A',0x0808);
	setAddress('SKEW_CTL_B',0x080C);
	setAddress('SKEW_CTL_C',0x0810);
	setAddress('MISC_CLK_CTL',0x0814);
	setAddress('AUX_IO_CTL',0x0818);
	setAddress('AUX_IO_DATA',0x081C);
	setAddress('AUX_INPUT_SELECT',0x0820);
	setAddress('SERDES_TPOWER',0x0828);
	setAddress('SERDES_RPOWER',0x082C);
	setAddress('SERDES_LOCAL_LE',0x0830);
	setAddress('SERDES_LINE_LE',0x0834);
	setAddress('LVDS_PREEMPHASIS',0x0838);
	setAddress('LINK_LRU_CTL',0x083C);
	setAddress('MISC_CTL1',0x0840);
	setAddress('MISC_CTL2',0x0844);
	setAddress('GENERIC_TEST_FIFO',0x0848);
	setAddress('DIAG_PIN_CTL_REG',0x084C);
	setAddress('MON1_FIFO_SEL',0x08A0);
	setAddress('MON2_FIFO_SEL',0x08A4);
	setAddress('MON3_FIFO_SEL',0x08A8);
	setAddress('MON4_FIFO_SEL',0x08AC);
	setAddress('MON5_FIFO_SEL',0x08B0);
	setAddress('MON6_FIFO_SEL',0x08B4);
	setAddress('MON7_FIFO_SEL',0x08B8);
	setAddress('MON8_FIFO_SEL',0x08BC);
	setAddress('CHANNEL_FIFO_CTL',0x08C0);
	setAddress('PULSED_CONTROL1',0x08E0);
	setAddress('PULSED_CONTROL2',0x08E4);
	setAddress('FIFO_RESETS',0x08F0);
	setAddress('DISC_BIT_MASK',0xA000);
	setAddress('FS_THRESH',0xE000);



makeAddrListTrigCommon()
makeAddrListTrigMaster()
	

				
    
#read line


#if field dtype, we will change, else write the line.

#re.search('(?<=field\(DTYP).*','  field(DTYP,asyn$(TIMER)1)').group(0)

